============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0 -- /root/sanctum-letta-mcp/venv/bin/python
cachedir: .pytest_cache
rootdir: /root/sanctum-letta-mcp
configfile: pytest.ini
plugins: asyncio-1.1.0, socket-0.7.0, timeout-2.4.0, anyio-4.10.0, cov-6.2.1, mock-3.12.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 8 items

temp/sse_test.py::test_mcp_protocol FAILED                               [ 12%]
tests/e2e/test_mcp_workflow.py::TestMCPWorkflowHTTP::test_list_tools_and_call_health ERROR [ 25%]
tests/integration/test_mcp_protocol.py::TestMCPProtocolInMemory::test_list_tools_contains_health PASSED [ 37%]
tests/integration/test_mcp_protocol.py::TestMCPProtocolInMemory::test_call_health FAILED [ 50%]
tests/unit/test_mcp_server.py::test_health_returns_expected_dict FAILED  [ 62%]
tests/unit/test_mcp_server.py::test_register_multiple_schedule_options_error FAILED [ 75%]
tests/unit/test_mcp_server.py::test_register_missing_schedule_error FAILED [ 87%]
tests/unit/test_mcp_server.py::test_upload_missing_auth_error FAILED     [100%]

==================================== ERRORS ====================================
____ ERROR at setup of TestMCPWorkflowHTTP.test_list_tools_and_call_health _____

self = <fastmcp.client.client.Client object at 0x7619aaa09820>

    async def _session_runner(self):
        """
        Background task that manages the actual session lifecycle.
    
        This task runs in the background and:
        1. Establishes the transport connection via _context_manager()
        2. Signals that the session is ready via _ready_event.set()
        3. Waits for disconnect signal via _stop_event.wait()
        4. Ensures _ready_event is always set, even on failures
    
        The simplified error handling (compared to the original) removes
        redundant exception re-raising while ensuring waiting tasks are
        always unblocked via the finally block.
        """
        try:
            async with AsyncExitStack() as stack:
>               await stack.enter_async_context(self._context_manager())

venv/lib/python3.12/site-packages/fastmcp/client/client.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:659: in enter_async_context
    result = await _enter(cm)
             ^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:210: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastmcp/client/client.py:341: in _context_manager
    with catch(get_catch_handlers()):
venv/lib/python3.12/site-packages/exceptiongroup/_catch.py:39: in __exit__
    raise unhandled from exc.__cause__
venv/lib/python3.12/site-packages/exceptiongroup/_catch.py:65: in handle_exception
    result = handler(matched)
             ^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastmcp/utilities/exceptions.py:29: in _exception_handler
    raise leaf
venv/lib/python3.12/site-packages/mcp/client/streamable_http.py:407: in handle_request_async
    await self._handle_post_request(ctx)
venv/lib/python3.12/site-packages/mcp/client/streamable_http.py:260: in _handle_post_request
    async with ctx.client.stream(
/usr/lib/python3.12/contextlib.py:210: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:1583: in stream
    response = await self.send(
venv/lib/python3.12/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_transports/default.py:393: in handle_async_request
    with map_httpcore_exceptions():
/usr/lib/python3.12/contextlib.py:158: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: All connection attempts failed

venv/lib/python3.12/site-packages/httpx/_transports/default.py:118: ConnectError

The above exception was the direct cause of the following exception:

self = <tests.e2e.test_mcp_workflow.TestMCPWorkflowHTTP object at 0x7619aa7adc40>
http_server_process = {'base_url': 'http://127.0.0.1:8100/mcp', 'host': '127.0.0.1', 'path': '/mcp', 'port': 8100, ...}

    @pytest_asyncio.fixture
    async def http_client(self, http_server_process):
        """
        Yield a connected FastMCP client that talks to the spawned HTTP server.
        http_server_process fixture provides base_url like http://127.0.0.1:8100/mcp
        """
        base_url = http_server_process["base_url"]
        client = Client(base_url)
>       async with client:

tests/e2e/test_mcp_workflow.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/fastmcp/client/client.py:362: in __aenter__
    return await self._connect()
           ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastmcp.client.client.Client object at 0x7619aaa09820>

    async def _connect(self):
        """
        Establish or reuse a session connection.
    
        This method implements the reentrant context manager pattern:
        - First call: Creates background session task and waits for it to be ready
        - Subsequent calls: Increments reference counter and reuses existing session
        - All operations protected by _context_lock to prevent race conditions
    
        The critical fix: Events are only created when starting a new session,
        never reset outside the lock, preventing the deadlock scenario where
        tasks wait on events that get replaced by other tasks.
        """
        # ensure only one session is running at a time to avoid race conditions
        async with self._session_state.lock:
            need_to_start = (
                self._session_state.session_task is None
                or self._session_state.session_task.done()
            )
            if need_to_start:
                if self._session_state.nesting_counter != 0:
                    raise RuntimeError(
                        f"Internal error: nesting counter should be 0 when starting new session, got {self._session_state.nesting_counter}"
                    )
                self._session_state.stop_event = anyio.Event()
                self._session_state.ready_event = anyio.Event()
                self._session_state.session_task = asyncio.create_task(
                    self._session_runner()
                )
                await self._session_state.ready_event.wait()
    
                if self._session_state.session_task.done():
                    exception = self._session_state.session_task.exception()
                    if exception is None:
                        raise RuntimeError(
                            "Session task completed without exception but connection failed"
                        )
                    if isinstance(exception, httpx.HTTPStatusError):
                        raise exception
>                   raise RuntimeError(
                        f"Client failed to connect: {exception}"
                    ) from exception
E                   RuntimeError: Client failed to connect: All connection attempts failed

venv/lib/python3.12/site-packages/fastmcp/client/client.py:406: RuntimeError
=================================== FAILURES ===================================
______________________________ test_mcp_protocol _______________________________

    def test_mcp_protocol():
        global sse_running, sse_resp
        test_success = True
        # Start SSE listener in background
        sse_thread = threading.Thread(target=sse_listener, daemon=True)
        sse_thread.start()
    
        try:
            # Wait for SSE connection and initial events
            time.sleep(2)
            headers = {"Content-Type": "application/json"}
    
            # Test 1: Initialize
            print("\n--- Testing Initialize ---")
            init_message = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "initialize",
                "params": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {"tools": {}},
                    "clientInfo": {"name": "letta", "version": "1.0.0"}
                }
            }
            response = requests.post(MESSAGE_URL, json=init_message, headers=headers, timeout=10)
            print(f"[MSG] Initialize Status: {response.status_code}")
            print(f"[MSG] Initialize Response: {json.dumps(response.json(), indent=2)}")
            if response.status_code != 200:
                test_success = False
    
            # Test 2: List Tools
            print("\n--- Testing Tools List ---")
            tools_message = {"jsonrpc": "2.0", "id": 2, "method": "tools/list"}
            response = requests.post(MESSAGE_URL, json=tools_message, headers=headers, timeout=10)
            print(f"[MSG] Tools List Status: {response.status_code}")
            print(f"[MSG] Tools List Response: {json.dumps(response.json(), indent=2)}")
            if response.status_code != 200:
                test_success = False
    
            # Test 3: Call Tool
            print("\n--- Testing Tool Call ---")
            call_message = {
                "jsonrpc": "2.0",
                "id": 3,
                "method": "tools/call",
                "params": {
                    "name": "devops.status",
                    "arguments": {"app-name": "test-app"}
                }
            }
            response = requests.post(MESSAGE_URL, json=call_message, headers=headers, timeout=10)
            print(f"[MSG] Tool Call Status: {response.status_code}")
            print(f"[MSG] Tool Call Response: {json.dumps(response.json(), indent=2)}")
            if response.status_code != 200:
                test_success = False
    
            # Let the SSE connection run for a few more seconds to simulate a real client
            time.sleep(2)
        except Exception as e:
            print(f"[TEST] Error: {e}")
            test_success = False
        finally:
            sse_running = False
            # Force close the SSE connection from the main thread
            if sse_resp is not None:
                try:
                    sse_resp.close()
                except Exception:
                    pass
            sse_thread.join(timeout=5)
            if sse_thread.is_alive():
                print("[SSE] Listener did not exit cleanly!")
                test_success = False
            else:
                print("[SSE] Listener closed.")
            if test_success:
                print("\n[TEST] MCP protocol test completed successfully.")
                sys.exit(0)
            else:
                print("\n[TEST] MCP protocol test failed.")
>               sys.exit(1)
E               SystemExit: 1

temp/sse_test.py:116: SystemExit
----------------------------- Captured stdout call -----------------------------
[SSE] Listener error: HTTPConnectionPool(host='localhost', port=8000): Max retries exceeded with url: /mcp/sse (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7619aa9951c0>: Failed to establish a new connection: [Errno 111] Connection refused'))

--- Testing Initialize ---
[TEST] Error: HTTPConnectionPool(host='localhost', port=8000): Max retries exceeded with url: /mcp/message (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7619aa7aff20>: Failed to establish a new connection: [Errno 111] Connection refused'))
[SSE] Listener closed.

[TEST] MCP protocol test failed.
___________________ TestMCPProtocolInMemory.test_call_health ___________________

self = <tests.integration.test_mcp_protocol.TestMCPProtocolInMemory object at 0x7619aa7aea20>
client = <fastmcp.client.client.Client object at 0x7619aa7fce60>

    @pytest.mark.asyncio
    async def test_call_health(self, client: "Client"):
        result = await client.call_tool("health", {})
        text = getattr(result, "text", None)
        if text is None and isinstance(result, dict):
            data = result
        else:
>           data = json.loads(text)
                   ^^^^^^^^^^^^^^^^

tests/integration/test_mcp_protocol.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = None, cls = None, object_hook = None, parse_float = None, parse_int = None
parse_constant = None, object_pairs_hook = None, kw = {}

    def loads(s, *, cls=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
        """Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
        containing a JSON document) to a Python object.
    
        ``object_hook`` is an optional function that will be called with the
        result of any object literal decode (a ``dict``). The return value of
        ``object_hook`` will be used instead of the ``dict``. This feature
        can be used to implement custom decoders (e.g. JSON-RPC class hinting).
    
        ``object_pairs_hook`` is an optional function that will be called with the
        result of any object literal decoded with an ordered list of pairs.  The
        return value of ``object_pairs_hook`` will be used instead of the ``dict``.
        This feature can be used to implement custom decoders.  If ``object_hook``
        is also defined, the ``object_pairs_hook`` takes priority.
    
        ``parse_float``, if specified, will be called with the string
        of every JSON float to be decoded. By default this is equivalent to
        float(num_str). This can be used to use another datatype or parser
        for JSON floats (e.g. decimal.Decimal).
    
        ``parse_int``, if specified, will be called with the string
        of every JSON int to be decoded. By default this is equivalent to
        int(num_str). This can be used to use another datatype or parser
        for JSON integers (e.g. float).
    
        ``parse_constant``, if specified, will be called with one of the
        following strings: -Infinity, Infinity, NaN.
        This can be used to raise an exception if invalid JSON numbers
        are encountered.
    
        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
        kwarg; otherwise ``JSONDecoder`` is used.
        """
        if isinstance(s, str):
            if s.startswith('\ufeff'):
                raise JSONDecodeError("Unexpected UTF-8 BOM (decode using utf-8-sig)",
                                      s, 0)
        else:
            if not isinstance(s, (bytes, bytearray)):
>               raise TypeError(f'the JSON object must be str, bytes or bytearray, '
                                f'not {s.__class__.__name__}')
E               TypeError: the JSON object must be str, bytes or bytearray, not NoneType

/usr/lib/python3.12/json/__init__.py:339: TypeError
----------------------------- Captured stdout call -----------------------------
2025-08-26 23:35:02,640 - mcp.server.lowlevel.server - INFO - Processing request of type CallToolRequest
2025-08-26 23:35:02,684 - mcp.server.lowlevel.server - INFO - Processing request of type ListToolsRequest
----------------------------- Captured stderr call -----------------------------
[08/26/25 23:35:02] INFO     Server log: Health check: {"status":  logging.py:40
                             "healthy", "letta_base_url":                       
                             "http://localhost:8283", "db":                     
                             "promptyoself.db", "auth_set": true}               
------------------------------ Captured log call -------------------------------
INFO     mcp.server.lowlevel.server:server.py:624 Processing request of type CallToolRequest
INFO     mcp.server.lowlevel.server:server.py:624 Processing request of type ListToolsRequest
______________________ test_health_returns_expected_dict _______________________

    @pytest.mark.asyncio
    async def test_health_returns_expected_dict():
        """
        The health tool should return a JSON-serializable dict with basic fields.
        """
>       result = await health()
                       ^^^^^^^^
E       TypeError: 'FunctionTool' object is not callable

tests/unit/test_mcp_server.py:28: TypeError
________________ test_register_multiple_schedule_options_error _________________

    @pytest.mark.asyncio
    async def test_register_multiple_schedule_options_error():
        """
        Registering with more than one schedule option should fail validation
        before any DB or network calls are attempted.
        """
>       result = await promptyoself_register(
            agent_id="agent-123",
            prompt="Hello",
            time="2025-01-01T10:00:00",
            cron="0 9 * * *",  # two options to trigger validation error
        )
E       TypeError: 'FunctionTool' object is not callable

tests/unit/test_mcp_server.py:42: TypeError
_____________________ test_register_missing_schedule_error _____________________

    @pytest.mark.asyncio
    async def test_register_missing_schedule_error():
        """
        Registering with no schedule options should fail validation.
        """
>       result = await promptyoself_register(
            agent_id="agent-123",
            prompt="Hello",
        )
E       TypeError: 'FunctionTool' object is not callable

tests/unit/test_mcp_server.py:58: TypeError
________________________ test_upload_missing_auth_error ________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7619aa6eb0b0>

    @pytest.mark.asyncio
    async def test_upload_missing_auth_error(monkeypatch):
        """
        Upload should require authentication; without LETTA_API_KEY/LETTA_SERVER_PASSWORD it should error.
        """
        # Ensure auth variables are not set
        for k in ("LETTA_API_KEY", "LETTA_SERVER_PASSWORD"):
            if os.environ.get(k):
                monkeypatch.delenv(k, raising=False)
    
>       result = await promptyoself_upload(
            source_code="""
    def tool_example(a: int, b: int) -> int:
        \"\"\"Add two numbers\"\"\"
        return a + b
    """,
            name="example",
            description="example tool",
        )
E       TypeError: 'FunctionTool' object is not callable

tests/unit/test_mcp_server.py:77: TypeError
==================================== PASSES ====================================
___________ TestMCPProtocolInMemory.test_list_tools_contains_health ____________
----------------------------- Captured stdout call -----------------------------
2025-08-26 23:35:02,429 - mcp.server.lowlevel.server - INFO - Processing request of type ListToolsRequest
------------------------------ Captured log call -------------------------------
INFO     mcp.server.lowlevel.server:server.py:624 Processing request of type ListToolsRequest
=========================== short test summary info ============================
PASSED tests/integration/test_mcp_protocol.py::TestMCPProtocolInMemory::test_list_tools_contains_health
ERROR tests/e2e/test_mcp_workflow.py::TestMCPWorkflowHTTP::test_list_tools_and_call_health - RuntimeError: Client failed to connect: All connection attempts failed
FAILED temp/sse_test.py::test_mcp_protocol - SystemExit: 1
FAILED tests/integration/test_mcp_protocol.py::TestMCPProtocolInMemory::test_call_health - TypeError: the JSON object must be str, bytes or bytearray, not NoneType
FAILED tests/unit/test_mcp_server.py::test_health_returns_expected_dict - TypeError: 'FunctionTool' object is not callable
FAILED tests/unit/test_mcp_server.py::test_register_multiple_schedule_options_error - TypeError: 'FunctionTool' object is not callable
FAILED tests/unit/test_mcp_server.py::test_register_missing_schedule_error - TypeError: 'FunctionTool' object is not callable
FAILED tests/unit/test_mcp_server.py::test_upload_missing_auth_error - TypeError: 'FunctionTool' object is not callable
=============== 6 failed, 1 passed, 4 warnings, 1 error in 6.72s ===============
